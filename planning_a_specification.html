<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Planning a Graphic – Data Visualisation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Data Visualisation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./planning_a_specification.html" aria-current="page"> 
<span class="menu-text">Planning a Graphic</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./grammar_of_graphics.html"> 
<span class="menu-text">Explaining the Grammar of Graphics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Planning_a_complex_graph.html"> 
<span class="menu-text">A Complex Graphic in Practice</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./animation_in_a_graphic.html"> 
<span class="menu-text">Animation with gganimate</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#what-makes-a-good-specification" id="toc-what-makes-a-good-specification" class="nav-link" data-scroll-target="#what-makes-a-good-specification">What makes a good specification?</a></li>
  <li><a href="#example-specification" id="toc-example-specification" class="nav-link" data-scroll-target="#example-specification">Example specification</a></li>
  <li><a href="#why-separting-specification-from-execution-improves-reproducibility" id="toc-why-separting-specification-from-execution-improves-reproducibility" class="nav-link" data-scroll-target="#why-separting-specification-from-execution-improves-reproducibility">Why separting specification from execution improves reproducibility?</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Planning a Graphic</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Planning is an important component for everything. Plans are outlines that you follow to make your intended product. For example, most buildings in the world have been planned in some way. Architects need to discuss what the purpose of the building is, and with that in mind, how do they design it to fit this need? They then need to plan where the building is going to go, and what materials and machines they need. A lot of planning goes into making a great building. This is the same for graphics. Having a specification (plan) will help lay foundations of what to include in the graph. Without plans, you may forget your original idea, you have no physical checkpoints to check off, so you have no accountability and everything isn’t thoroughly thought through yet. I will now explain what makes a good specification for a graphic and provide an example with the principles of what makes a good specification</p>
</section>
<section id="what-makes-a-good-specification" class="level2">
<h2 class="anchored" data-anchor-id="what-makes-a-good-specification">What makes a good specification?</h2>
<p>A good specification is specific with its planning, and thinks about all constraints and limitations. It thinks about all the components you need to make your graph. It will also answer lots of questions about design choices and explain things concisely enough that someone can read your specification, and make a graph exactly, or very close to what you intended with any software/tools. One thing specifications should include is the grammar of graphics. The grammar of graphics is a structure which visualisers should follow to make a graph that makes sense. Its like language structure. Back in school, we learn grammar, which teaches you where to place commas and full-stops when writing and how to make sentences make sense. This is the exact concept of the grammar of graphics.</p>
<p>Your first section should be dedicated to the purpose of your graphic and what question you want it to answer. For example, you may be collecting data on user experience for UX design. You may want to answer the question “what designs do users like the most, and which ones do they like the least?”. Having this purpose will let you decide what you want the whole graph to look. The type of your data your working with to make your graphic, will also influence the rest of the components of your graph. Some components are only possible with certain types of data, so making sure you know the purpose of the graph, and what question you want to answer, will provide a foundation of what to include in your graph. This section should be clear and provide what story you want to tell with your data.</p>
<p>The rest of the sections will be design based, meaning it will include components you need in graph. This is where you should follow the grammar of graphics. The first component of the grammar of graphics is data. Data is the foundation of all graphs. Its what will be shown on the graph, and its what you use to tell your story. For your data, you need define the variables you have collected. If you are looking to make a graph about employee retention, you should include all the data you have like names of employees, how long they worked there, when they worked there and maybe their salary. Once you have this, you will know exactly what other components you can use in your graph. Some components can only be used with some data, like how probability is only for data that is numeric/continuous. So, having this known will make the rest of the specification easier. So, you need list all the variables then include what kind of data it is like categorical data or continuous data. For example, names would be categorical, years of employment would be continuous, when they worked there would be continuous and their salary is continuous. Here you could also cover transformations. These are changes to your data to summarise it. This can include means, counts and ranges. You would explain why you need these.</p>
<p>The next section of your specification is aesthetics. This where you plan what you want shown on the graph. For example, this is where you explain your x and y axes, what colours you want to use etc. You should be clear on what data you want using in your graph and explain why. This is the first major design question you answer. The aesthetics are what will be placed on the graph, so they are a huge component to how a graph looks.</p>
<p>Next you should explain geometries. You will explain what geometry you want to use and why. You should say why a specific geometry is needed. It could be because the data you have best fits a certain geometry, or it because it allows you tell a specific story you want. For example, you may choose points because it will allow you later to make them bigger as the values get bigger, which can enhance your message because viewers can see a physical impact of something increasing or decreasing. Also, while having a clear and documented reason why you chose a geometry, you can get feedback for when the graph is made to make sure viewers will interpret your graph the way you want it to. Your mind can be deceived because it knows what the graph is intended to show, so you might not catch something wrong with it that can lead to viewers misinterpreting the graph. You can also explain statistical elements. These are the visuals of transformations to data. If this is explicable to your graph, you should do the same as you did for the raw data geometry. Explain what statistical element you want, and why you have chosen it. This will give you a vision that you can use to make sure your graph follows your specification well.</p>
<p>Your next section should cover scales. Scales are visuals of our data. Geometries draw our data-points, scales are how we want our data to be shown visually. You should explain clearly and concisely, what scales you want including and why. Explain how they enhance the graph and why they are needed to make your graph how you want. Don’t specific lines of code you want to use. This is because code like <code>scales_y_coninuous</code> is exclusive to ggplot. Ggplot is a library within R studio that was made from the grammar of graphics. However, not having code will improve reproducibility. This is because there are a variety of tools that people use, not just ggplot. Those tools will have different syntaxes and rules. So, making sure that you don’t cover tool exclusive code will make sure that it can be reproduced no-matter the tools you are using.</p>
<p>Your next section should be coordinates. Again, you need to be concise with what coordinates you want and why you need them. You should explain what coordinates you will need, like Polar or Cartesian coordinates. You should explain why you need them and how you plan to use them. You should try and explain the exact positioning you want. You can do this in a variety ways. You can explain in words if you want to zoom in on a specific part of the graph. You can also use images to show the positioning and explain why you want it there.</p>
<p>The final section should then be explaining guides. You need to explain the title of your graph, and what you want to name your x and y axes and your legend if applicable. You don’t need to necessarily explain why you chose your title and x and y axes names, because that can be self-explanatory given you previously explain the purpose and question your graph is answering. The legend can be changed position however, and that can have some explanation. This could be for readability or for purely aesthetic reasons.</p>
<section id="overview" class="level4">
<h4 class="anchored" data-anchor-id="overview">Overview</h4>
<p>A common theme with all the sections is explaining things in depth and giving reason. This lets you think about what you are planning, and this can let you discover flaws early on, rather than later in development. It also gives you checkpoints and visions your final graph should have. It will also make the graph reproducible by someone who has read your specification.</p>
</section>
</section>
<section id="example-specification" class="level2">
<h2 class="anchored" data-anchor-id="example-specification">Example specification</h2>
<p>Below is an example specification for a graph for a data-set on weather over the last 5 years. This will have all the sections as discussed above with the depth and explanation needed:</p>
<section id="purpose-of-graphic" class="level4">
<h4 class="anchored" data-anchor-id="purpose-of-graphic">Purpose of graphic</h4>
<p>Global warming has been an issue for decades now. It has caused un-predictable weather events that cause lots of destruction. Lots of people however don’t think about it, or think it won’t affect them in their lifetime, so they do nothing about it. In order to tackle this, i have a data-set that has data on weather across every country in the UN. This will open the eyes of people who deny global warming, and to show the scale of it now, and paint a picture in peoples heads that if it carries on, this already destructive weather will get worse. The question i want my graph is answer is “How has the weather changed over the past 5 years?”. I have data on weather from January to December for 2020 to 2025.</p>
</section>
<section id="data" class="level4">
<h4 class="anchored" data-anchor-id="data">Data</h4>
<p>What data do I have? I have data on the average temperature across the whole month for 5 whole years. These are the years between 2020 and 2025. I have chosen to get such recent data because it will show how it is now, not how it was in the past. Other graphs showing weather change are from the 1990’s to now. I want to show how its changed in the current decade. People may think if they see data from years ago and think “that was 30 years ago, it wont be another 20 or 30 years until its uncontrollable”. If they see more short-term damage, they will be aware its much sooner then they think until its completely uncontrollable. The type of data i have is continuous/numeric. The variables will include year, which will have 2020, 2021, 2022, 2023, 2024 and 2025. I will then have a month variable, which will include all the months of the year. I will then have a temperature variable, with the average temperature for each month.</p>
</section>
<section id="aesthetics" class="level4">
<h4 class="anchored" data-anchor-id="aesthetics">Aesthetics</h4>
<p>For aesthetics, my x axis will be the months of the year and the y axis will be temperatures. Then, each month will have a bar for each year going up to the average temperature of that month for that year. I also plan for colours to be associated with year. This means that each year will have a specific colour. For example, all data that is associated with the year 2020 could be red, all data for 2021 green etc. I chose to have bar charts because it will be easier to read. If i did points, it would be much harder to decipher which points are for what year. They may also over-lap and be really close together which can make it hard to look at and analyse.</p>
</section>
<section id="geometries" class="level4">
<h4 class="anchored" data-anchor-id="geometries">Geometries</h4>
<p>As mentioned before, my geometry would be bars. This will mean each year will have a separate bar to display the average temperature. I have chosen this because its the most fitting. A histogram wouldn’t work because it focuses on singular variables, rather than multiple. So, a barchart is a better fit. Also, since I’m doing multiple bars for one data-value, having them touch for every month will make it confusing for the viewer to know which ones are for what month. Lines won’t work because it will cause overplotting, meaning lines for one month will cover the other. This is will make it unreadable, and make it hard to notice trends.</p>
</section>
<section id="scales" class="level4">
<h4 class="anchored" data-anchor-id="scales">Scales</h4>
<p>Scales are how data is visually seen. We just declare what we want shown in aesthetics, they don’t place them. Scales let us decide how we visualise our aesthetics. The scales i will apply is reordering data. For the months data, they can sometimes be shown in alphabetical order, so i will rearrange the data so the months appear as they do on the calender (January, February etc). I have chosen this so the data is easier to follow. If it was in alphabetical order, viewers would find it hard to read the graph because most people are used to the calender order of the months. I won’t apply any other scales. This is because i want to show people the raw data and just how it is. I don’t want people focused on specific data areas, i want viewers to see the whole thing, as it is. It will also look better for the general viewer.The general public may not want to see a complex graph. They may see the graph as more for professionals, so they wont look at it.</p>
</section>
<section id="coordinates" class="level4">
<h4 class="anchored" data-anchor-id="coordinates">Coordinates</h4>
<p>For coordinates, i won’t apply any. Doing anything extra wouldn’t benefit the graph. For example, i can’t apply polar coordinates because they create pie-charts, so it wouldn’t match my vision because pie charts are comparing values to a complete value. Since we are working with temperature, there isn’t a total value, so a pie chart wouldn’t work. Including fixed coordinates, which are coordinates that are set in stone once applied, meaning that the graph won’t be distorted if anything else is applied, like a transformation. Since however I’m not applying a transformation that will make including a fixed coordinate make sense.</p>
</section>
<section id="guides" class="level4">
<h4 class="anchored" data-anchor-id="guides">Guides</h4>
<p>For guides, the title of the graph would be “Average temperature for the past 5 years”. This a title that easily explains what the viewer is looking at. It’s not too long or has complicated words or abbreviation of words that the average viewer may not know. I will also label my x axis to be “Months” and the y axis to be “Temperature (degrees Celsius)”. I have added the “degrees Celsius” so people know what it’s measured in. Other parts of the world use Fahrenheit, which is a completely different scale to Celsius. I will also rename the legend to “Years”. This is so people know that the legend is to show the colour for each year. I will also adjust the size of the title of the graph. This is so the graph can catch more peoples attention. It will also bring more attention to what the graph is about. Viewers may not see a smaller title, so they will look at the graph, get confused then look at the title. However if the title is big, people will know immediately what the graph means, rather than guessing.</p>
</section>
</section>
<section id="why-separting-specification-from-execution-improves-reproducibility" class="level2">
<h2 class="anchored" data-anchor-id="why-separting-specification-from-execution-improves-reproducibility">Why separting specification from execution improves reproducibility?</h2>
<p>Specification is the planning, execution is actually producing the graph. With execution, this is where we open our graphic software and actually do the code to make it. We follow the specification we write and we make our intended graph. However, when writing your specification, you can’t combine it with execution. This is because different graphical software and tools has its own limitations and functions. If you think about how to make it in for example ggplot and R studio, the things you do may not be possible on other software or tools. You need to mention generic things, not anything specific. The grammar of graphics is a good example of reproducibility. The grammar of graphics is structure for a graph, not something exclusive to a tool or software. So, using this framework for your specification allows for reproducibility.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Leland Wilkinson (2005) <em>Statistics and computing: The Grammer of Graphics (Second Edition)</em>. New York; Springer</p>
<p>University of Colorado Boulder (2021) <em>A Grammer of Graphics</em>. Available at: https://www.youtube.com/watch?v=RCaFBJWXfZc (Accessed: 07/01/2026)</p>
<p>https://vle.harper-adams.ac.uk/course/view.php?id=287 (07/01/2026)</p>
<p>https://vle.harper-adams.ac.uk/course/view.php?id=287 (08/01/2026)</p>
<p><strong>AI has been used in this document (Used for researching and structure for specification)</strong></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>